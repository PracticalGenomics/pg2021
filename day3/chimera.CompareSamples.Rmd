---
title: "Comparing Samples"
author: "Luigi Marchionni"
date: "9/25/2021"
output: html_document
---

# Preliminary operations

```{r compileRMD, echo=FALSE, eval=TRUE}
### Libraries necessary for knitting
library(rmarkdown)
```

## Load the required general libraries for typesetting

```{r setup}
### Clean the workspace
rm(list=ls())
ls()
### Load the required libraries
library(knitr, quietly = TRUE)
knitr::opts_chunk$set(echo = TRUE)
### To run and output elsewhere
knitPath <- "/home/idies/workspace/practical_genomics/day3/"
# knitPath <- "."
print(knitPath)
opts_knit$set(root.dir = knitPath) #tidy=TRUE, tidy.opts=list(width.cutoff=180))
```

## Set the correct working directory

```{r}
### Finding your current working directory
getwd()
### Setting the working directory (change this)
setwd(knitPath)
### Check working directory
getwd()
```

# Comparing multiple samples
Comparing multiple samples, and basically making sure to some extent that your observations generalize when n > 1 is possibly one of the most important question one might want to ask. With single cell technologies, this translates to be able to ask questions like "are genes differentially expressed, or cell populations differentially represented between phenotypes?". These differential analyses can be cathegorized into two distinct analysis types: differential expression (DE) and differential abundance (DA).

## Preparing the data
To exempify these analyses, we will analyze samples from early mouse embryo development (day E8.5), comparing chimeric embryos generated by injecting td-Tomato-positive embryonic stem cells (ESCs) to their wild-type (WT) blastocyst countepart. The aim of this study is to identify the differences in lineage commitment determined by the injection procedure itself (see, Pijuan-Sala et al. Nature, 2019). In this experiment, a paired design was used, with three replicates of the two matched samples, generating scRNA-seq data using the 10X Genomics protocol.

We will start by loading the data we have already pre-processed (for the complete code, please see file named "chimera.prepareData.Rmd" inside the folder named "day3").


For our purpose today we will use a merged singe cell expression dataset processed using all steps previously covered. Specifically cells were already merged from all samples and also already partioned and clustered. The visual inspection of clustering results demonstates that clusters contain comparable contributions from different batches. Furthermore, for our analyses, we will also rely on the cell types identified in the original publication, although this might not be optimal, given the inherent difficulty in unambiguously resolving cell types undergoing differentiation. These clusters'labels are shown and numbered in the figure below.

```{r}
### Load the merged data
load("./chimera.sce.merged.rda")
### Load necessary library
library(scater, quietly = TRUE)
### Check cluster composition by phenotype
table(colLabels(merged), merged$tomato)
### Check cluster composition by sample
table(colLabels(merged), merged$pool)
### Now plot side by side
gridExtra::grid.arrange(
    plotTSNE(merged, colour_by="tomato", text_by="label"),
    plotTSNE(merged, colour_by=data.frame(pool=factor(merged$pool))),
    ncol=2)
```

## Differential expression between conditions

### Creating pseudo-bulk samples

Differential gene expression analysis between conditions can be obtained for each cell type/cluster, hence identifying cell type-specific changes. This is analysis is performed on "pseudo-bulk" expression profiles obtained by summing together the counts for all cells with the same label/sample combination. This enables leveraging the statistical rigor of existing methods for DE analysiss with single cell resolution data. Additional motivations for using pseudo-bulking are found in OSCA Chapter 14. To create pseudo-bulk samples we can use the `aggregateAcrossCells()` function, as follows.

```{r}
### We will create 'pseudo-bulk' counts for all 'cluster/sample' combinations.
summed <- aggregateAcrossCells(merged, 
    id=colData(merged)[,c("celltype.mapped", "sample")])
### Check
summed
```

### Performing the DE analysis

DE analysis for count data is usually performed by fitting a negative binomial generalized linear model (as implemented in the `edgeR` package) to handle overdispersed count data with limited number of replicates. In our analysis here, we will focus on one cell type as an example.

```{r}
### Pick a cell type 
label <- "Mesenchyme"
### Subset the data
current <- summed[,label==summed$celltype.mapped]
### Check the resulting object
current
### Load the 'edgeR' package
library(edgeR, quietly = TRUE)
### Create an object of 'DGEList' class to be used in 'edgeR'
y <- DGEList(counts(current), samples=colData(current))
### Check
y
```

### Pre-processing pseudo-bulk data

In a typical bulk RNA-seq analyses, samples with very low library size are usually removed, since low counts from these samples can affect downstream analytical steps. Similarly, in pseudo-bulk analysis, we should remove cluster-sample combinations with very few cells. Here we will filter out pseudo-bulk profiles with less than 10 cells, however this is somewhat arbitrary, and standard diagnostic exploration for bulk DE can be applyed to guide this decision.

```{r}
### Check if there are psudo-bulk combinations with less than 10 cells
discarded <- current$ncells < 10
### Here we will not discard any psudo-profile
table(discarded)
y <- y[,!discarded]
```

Next, similarly to standard bulk RNA-seq analyses, we want to removelowly expressed genes. This improves the modelling accuracy of mean-variance trend, and mitigates ths multiple testing problem. To this end, we rely on  the `filterByExpr()` function from `edgeR` package. Specifically, we will remove genes that are not expressed above a certain log-CPM threshold in a minimum number of samples (which in turn depends on the smallest treatment group).

```{r}
### Which genes to keep
keep <- filterByExpr(y, group=current$tomato)
### How many?
table(keep)
### Subset
y <- y[keep,]
```

Finally, we can normalize the the expression data using M-values trimmed means, as done for bulk RNA-seq data since the counts for the pseudo-bulk samples are large enough. Here we will use the `calcNormFactors()` function from `edgeR`. 

```{r}
### Compute normalization factors and normalize data
y <- calcNormFactors(y)
y$samples
```

We can then monitor the results of this step by performing a mean-difference (MD) plot for each normalized pseudo-bulk profile. The cloud of genes should be centered on zero and shaped like a trumpet.

```{r}
### Define a layout for the image
layout(matrix(1:6, ncol=3))
### Plot all 6 samples
invisible(lapply(1:ncol(y), function(i, y) {
  plotMD(y, column=i)
  grid()
  abline(h=0, col="blue")
  }, y=y))
```

We can also generate a multi-dimensional scaling (MDS) plot to visualize the relationship of the pseudo-bulk profiles (we don't need techniques like t-SNE here, since we don't have many samples).

```{r}
### Multi-dimensional scaling (MDS) plot
plotMDS(cpm(y, log=TRUE), col=ifelse(y$samples$tomato, "red", "blue"))
```

### Statistical modelling

We can now set up a design matrix to control for batch differences across different embryo pools (blocking), while analyzing the log-fold change in gene expression due to the treatment of interest (here the injection of the embryos) to identify the most significant differentially expresseed genes.

This will be achieved through running the `estimateDisp()` function to estimate the negative binomial (NB) dispersions, and then fitting a generalized linera model to these counts using the `glmQLFit()` function (which models uncertainty and variability of per-gene variances using quasi-likelihood dispersion). Finally, we can test for differential expression using `glmQLFTest()`.
The rationale for using this approach is found in the `edgeR` package vignette.

```{r}
### Create the design matrix
design <- model.matrix(~factor(pool) + factor(tomato), y$samples)
design
### Estimate the dispersion
y <- estimateDisp(y, design)
### Compute the quasi-likelihood dispersions
fit <- glmQLFit(y, design, robust=TRUE)
### Find differentially expressed genes
res <- glmQLFTest(fit, coef=ncol(design))
### Count the number of significant genes
summary(decideTests(res))
### Report the results into a table
kable(topTags(res, n = 20))
```

### Analyze all pseudo-bulk samples at once

We are interested in modeling changes in gne expression for all cluster/samples combinations. This can be conveniently done using the `pseudoBulkDGE()` function from the `scran` package. This function returns a list with the the results for each label, inlcuding the intermediate `edgeR` objects used for the differential expression analyses. This function allows also the users to perform this analysis using the `voom()` pipeline from the `limma` package.

```{r}
### First we will removing all pseudo-bulk samples with 'insufficient' cells.
summed.filt <- summed[,summed$ncells >= 10]
dim(summed.filt)
### Load the scran package
library(scran, quietly = TRUE)
### Perform the differential expression analysis for all pseudo-bulk samples
de.results <- pseudoBulkDGE(summed.filt, 
    label=summed.filt$celltype.mapped,
    design=~factor(pool) + tomato,
    coef="tomatoTRUE",
    condition=summed.filt$tomato 
)
### Check the results
class(de.results)
names(de.results)
### These are the cell type for which the analysis failed
metadata(de.results)$failed
### Let's check the result for one  pseudo-bulk sample
cur.results <- de.results[["Allantois"]]
### sort by p.valus
cur.results <- cur.results[order(cur.results$PValue, decreasing = FALSE),]
head(cur.results, n=10)
```

### Cross-label meta-analyses

Since we analyzed all label/sample combinations, we can count the numbers of differentially expressed genes at a given FDR of 5% using the `decideTestsPerLabel()` function. The function
`summarizeTestsPerLabel()` will summarize such results for each cell type.

```{r}
### Count the DEGs for all lables
is.de <- decideTestsPerLabel(de.results, threshold=0.05)
### Check
class(is.de)
dim(is.de)
head(is.de[,1:5])
table(is.de[,"Allantois"])
### There are different NAs count because different genes were filtered in each cell type
kable(summarizeTestsPerLabel(is.de))
```

We can also identify genes consistently differentially expressed upon treatment (here is embryo injection) across all cell types.

```{r}
### Idenfify up-regulated genes across most cell types.
up.de <- is.de > 0 & !is.na(is.de)
head(sort(rowMeans(up.de), decreasing=TRUE), 10)
### Idenfify down-regulated genes across most cell types.
down.de <- is.de < 0 & !is.na(is.de)
head(sort(rowMeans(down.de), decreasing=TRUE), 10)
```

Finally, we can identify label-specific DE using the `pseudoBulkSpecific()` function, which test for significant differences in the fold-change of one labels against all other labels. Basically, this approach allows tos find the genes that change differently with treatment across the differetent cell types. This is conceptually similar to fitting an interaction model.

```{r}
### Identfy differentially expressed genes for each label
### Basically, let's find the genes that change differently with treatment across cell types
de.specific <- pseudoBulkSpecific(summed.filt,
    label=summed.filt$celltype.mapped,
    design=~factor(pool) + tomato,
    coef="tomatoTRUE",
    condition=summed.filt$tomato)
### Let's look at one cell type
cur.specific <- de.specific[["Allantois"]]
### Reorder by p-value
cur.specific <- cur.specific[order(cur.specific$PValue, decreasing = FALSE),]
head(cur.specific, n=10)
### Let's plot the results
sizeFactors(summed.filt) <- NULL
### Let's plot the result for one gene
gns <- "Slc22a18"
plotExpression(logNormCounts(summed.filt),
    features=gns,
    x="tomato", colour_by="tomato",
    other_fields="celltype.mapped") +
    facet_wrap(~celltype.mapped)
```

Note that if we rely use the output from `decideTestsPerLabel()`, we can identify the genes that are significant in our label of interest and not DE in any other label.

```{r}
#### Finding all genes that are not remotely DE in all other labels.
remotely.de <- decideTestsPerLabel(de.results, threshold=0.5)
not.de <- remotely.de==0 | is.na(remotely.de)
not.de.other <- rowMeans(not.de[,colnames(not.de)!="Allantois"])==1
#### Intersecting with genes that are DE inthe allantois.
unique.degs <- is.de[,"Allantois"]!=0 & not.de.other
unique.degs <- names(which(unique.degs))
#### Inspecting the results.
de.allantois <- de.results$Allantois
de.allantois <- de.allantois[unique.degs,]
de.allantois <- de.allantois[order(de.allantois$PValue, decreasing = FALSE),]
dim(de.allantois)
de.allantois
```

## Gene set enrichment analysis

### Load necessary libraries

We will now perform Gene Set Enrichment Analysis (GSEA) on the results from differential gene expression. To this end, we will need packages providing the infrastructure to handle functional gene set (FGS) lists (i.e., lists of genes capturing a biological concept), and the functions to perform the necessary and suitable statistical tests.

```{r}
### Let's load the needed packages, install it if not available
### First a library with data from the Molecular Signature Database
if (!"msigdbr" %in% installed.packages()[,"Package"]) {
  library(BiocManager)
  BiocManager::install("msigdbr")
}
### Load the library
library(msigdbr, quietly = TRUE)
### Then a library with functions to perform GSEA
if (!"fgsea" %in% installed.packages()[,"Package"]) {
  library(BiocManager)
  BiocManager::install("fgsea")
}
### A library to run GSEA
library(fgsea, quietly = TRUE)
```

### Prepare data: ranking statistics
Here we will test whether any FGS is enriched in the list of differentially expresed genes we have identified for our trietment of interest (here the embryo injection). To this end, we will need to prepare the data by extracting gene ranking based on a suitable statistics (e.g., t-statistics, fold-change, p-value, etc, ...). Here, for instance, we can use the output from the `pseudoBulkSpecific()` or` pseudoBulkDGE()` functions, rank the genes by the F-statistics, and use the fold-change sign to assign a direction to the change.

```{r}
### We are going to compute ranking stats from the output of `pseudoBulkSpecific()`
### Let's check the results for one cell type
head(de.specific$Allantois)
### Get ranking statistics for all cell types
rankStats <- lapply(de.specific, function(x) {
  ### Drop NAs
  x <- x[!is.na(x$PValue),]
  ### Compute ranking stat
  out <- -1*log(x$PValue) * sign(x$logFC)
  ### Get rid of NAs
  out <- out
  ### Add rownames
  names(out) <- rownames(x)
  ###Return the object
  return(out)
})
### Check output
class(rankStats)
names(rankStats)
str(rankStats[1:5])
### Plot
hist(rankStats$Allantois, nclass=50)
```

### Prepare data: gene sets
We will use the `msigdbr` package to extract Functional Gene Set.

```{r}
#### Select a feew collections from MSigDB
collections <- list()
collections$BIOCARTA <- msigdbr(species = "Mus musculus", category = "C2", 
                                subcategory = "BIOCARTA")
collections$CGP <- msigdbr(species = "Mus musculus", category = "C2", 
                                subcategory = "CGP")
collections$HALLMARKS <- msigdbr(species = "Mus musculus", category = "H") 
### Exrtract only the gene symbols and structure it as needed downstream
collections <- lapply(collections, function(x) {
  out <-  split(x = x$gene_symbol, f = x$gs_name)
})
### Check the output
class(collections)
names(collections)
str(collections$BIOCARTA[1:5])
```

### Perform enrichment analysis
We will now perfomr the enrichment analysis for one collection and one cell type.
To this end, we will use the `fgsea()` function from the `fgsea` package.
We can also plot the results using `plotGseaTable()`.

```{r}
### Runing enrichment analysis for one collection on the DE results for one populaiton 
gseOut <- fgsea(collections$CGP, rankStats$Allantois, maxSize=500)
### Check the results
head(gseOut)
### Get the top pathways
topFGS <- c(head(gseOut[order(NES, decreasing=FALSE),])$"pathway",
            head(gseOut[order(NES, decreasing=TRUE),])$"pathway")
### We can also plot the results 
plotGseaTable(collections$CGP[topFGS], rankStats$Allantois, gseOut, gseaParam=0.5)
```

# Session information
```{r}
sessionInfo()
```






